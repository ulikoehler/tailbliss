<meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="apple-touch-icon" sizes="180x180" href="{{ (resources.Get "favicon-180x180.png").RelPermalink }}">
<link rel="icon" href="{{ (resources.Get "TechOverflow.svg").RelPermalink }}">
<link rel="icon" type="image/png" sizes="192x192" href="{{ (resources.Get "favicon-192x192.png").RelPermalink }}">
<link rel="icon" type="image/png" sizes="32x32" href="{{ (resources.Get "favicon-32x32.png").RelPermalink }}">
<link rel="icon" type="image/png" sizes="16x16" href="{{ (resources.Get "favicon-16x16.png").RelPermalink }}">

<link rel="manifest" href="{{ (resources.Get .Site.Params.webmanifest).RelPermalink }}">
<!--<link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#5bbad5">-->
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
{{ partial "meta" . }}
<script>
    // On page load or when changing themes, best to add inline in `head` to avoid FOUC
    if (localStorage.getItem('color-theme') === 'dark' || (!('color-theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        document.documentElement.classList.add('dark');
    } else {
        document.documentElement.classList.remove('dark')
    }
</script>
{{ $styles := resources.Get "/css/style.css" | postCSS }}
{{ if hugo.IsServer }}
<link rel="stylesheet" href="{{ $styles.RelPermalink }}" />
{{ else }}
{{ $styles := $styles | minify | fingerprint | resources.PostProcess }}
<link rel="stylesheet" href="{{ $styles.RelPermalink }}" integrity="{{ $styles.Data.Integrity }}" />
{{ end }}
{{ range .Site.Params.custom_css -}}
<link rel="stylesheet" href="{{ (resources.Get . | postCSS).RelPermalink }}">
{{- end }}
{{/*
    Structured data (JSON-LD Article)

    Inclusion:
    - Only injected for single content pages where the page `.Section` equals "posts".

    Author selection priority:
    1. Post frontmatter `author` (i.e. `.Params.author`) — preferred and post-specific.
    2. Git author (`.GitInfo.AuthorName`) — fallback when frontmatter is missing and site is tracked with git.
    3. Site param `author` (i.e. `.Param "author"`) — last-resort global fallback.

    Dates:
    - `datePublished` is truncated to midnight (00:00:00) but preserves the original timezone offset.
    - `dateModified` uses either the Git modification date if available or `.Lastmod`.

    Images:
    - Prefer `.Params.images[0]` or `.Params.image` if present, then fallback to site params if needed.

    Git data:
    - When `.GitInfo` is available we include the abbreviated commit hash as `identifier`/`version`.
*/}}
{{ if and .IsPage (eq .Section "posts") }}
        {{ $git := .GitInfo }}
        {{/* Prefer frontmatter `.Params.author`, then Git author, then site param `author` */}}
    {{ $authorName := "" }}
    {{ with .Params.author }}{{ $authorName = . }}{{ end }}
    {{ if and (eq $authorName "") $git }}{{ if ne $git.AuthorName "" }}{{ $authorName = $git.AuthorName }}{{ end }}{{ end }}
    {{ if eq $authorName "" }}{{ $authorName = (.Param "author") }}{{ end }}
        {{/*
            Determine dateModified source:
            - Use the git author date when `.GitInfo` provides it (most accurate for last edit)
            - Otherwise fall back to Hugo's `.Lastmod`
        */}}
        {{ $dateModifiedSource := cond (and $git (ne $git.AuthorDate nil)) $git.AuthorDate .Lastmod }}

        {{/*
            datePublished: truncate time to midnight (00:00:00) but keep original timezone offset.
            This ensures published dates are normalized while still expressing the site's TZ.
        */}}
        {{ $publishDate := .Date }}
        {{ $tz := $publishDate.Format "Z07:00" }}
        {{ $datePublished := printf "%sT00:00:00%s" ($publishDate.Format "2006-01-02") $tz }}

            {{/*
                dateModified: use the date portion of the last-modified source and
                truncate the time to midnight while preserving timezone offset.
                This mirrors `datePublished` but reflects the last edit day.
            */}}
            {{ $modifiedTime := time $dateModifiedSource }}
            {{ $modifiedTz := $modifiedTime.Format "Z07:00" }}
            {{ $dateModified := printf "%sT00:00:00%s" ($modifiedTime.Format "2006-01-02") $modifiedTz }}
        {{/*
            Image selection priority:
            1. `.Params.images[0]` (array of images in frontmatter)
            2. `.Params.image` (single image in frontmatter)
            3. Site param `featureImage` as a final fallback
        */}}
        {{ $image := "" }}
        {{ with .Params.images }}{{ if gt (len .) 0 }}{{ $image = index . 0 }}{{ end }}{{ end }}
        {{ with .Params.image }}{{ $image = . }}{{ end }}
        {{ if and (eq $image "") (.Param "featureImage") }}{{ $image = (.Param "featureImage") }}{{ end }}
    {{ $data := dict
            "@context" "https://schema.org"
            "@type" "Article"
            "headline" .Title
            "description" (or .Description .Summary)
            "datePublished" $datePublished
            "dateModified" $dateModified
            "author" (dict "@type" "Person" "name" $authorName)
            "mainEntityOfPage" (dict "@type" "WebPage" "@id" .Permalink)
            "url" .Permalink
            "wordCount" .WordCount
    }}
    {{ if ne $image "" }}{{ $data = merge $data (dict "image" (absURL $image)) }}{{ end }}
    {{ if $git }}{{ $data = merge $data (dict "identifier" $git.AbbreviatedHash "version" $git.AbbreviatedHash) }}{{ end }}
    <script type="application/ld+json">
    {{ $data | jsonify }}
    </script>
{{ end }}